##对于不同 GC 和堆内存的总结
以执行GCLogAnalysis为例
串行GC
设置堆内存256m时，由于年轻代堆内存太小，短时间就触发Full GC,老年代内存堆满，新生代内存过小，导致触发young GC频率偏高，导致新生代晋升失败，执行4139次。
设置堆内存512m时，仅触发Young GC多次，未触发Full GC,堆内存充足，执行10043次。
设置堆内存1g时，仅触发Young GC很少，未触发Full GC,堆内存充足，执行10299次。

并行GC
设置堆内存256m时，由于年轻代堆内存太小，短时间就触发Full GC,老年代内存堆满，新生代内存过小，导致触发young GC频率偏高，导致新生代晋升失败，执行3992次。
设置堆内存512m时，触发Young GC多次，由于老年代内存过小，导致新生代对象晋升到老年代，一直触发Full GC，执行8526次。
设置堆内存1g时，仅触发Young GC很少，触发一次Full GC,执行时间为：65ms，代表堆内存越大STW执行时间越长，执行12593次。
设置堆内存4g时，触发young GC花费时间329ms，新堆内存太大导致STW时间过长，执行7915次。

CMS GC
设置堆内存1g时，并发执行young GC和业务逻辑，执行11703次。
设置堆内存4g时，触发young GC的时间平均70ms左右与并行GC相比，CMS GC针对于堆内存较大的更适合，执行11703次。

G1 GC
设置堆内存1g时，处理young GC 后，理对region区进行初始标记、root区扫描、并分标记，再次标记、清理、转移暂停，执行11619次。
设置堆内存4g时，只对年轻代做了young GC处理，执行时间大约为：65ms，执行10814次。

总结:
串行GC使用单线程垃圾收集器，只能在小内存的jvm中使用即可
并行G的堆内存不能太小，堆内存的空间不要设置太大，会导致在STW过程中清理时间过长，并且不能STW期间不能并行处理
CMS GC是针对老年代的内存清理，不会进行内存整理，在进行STW时能进行并发处理。
G1 GC使用分成多个region进行管理，通过阈值来触发young gc 、old gc 、full gc，针对堆内存较大，推荐使用G1 GC